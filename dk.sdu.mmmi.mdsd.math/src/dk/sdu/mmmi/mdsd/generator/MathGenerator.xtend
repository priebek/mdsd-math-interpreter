/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.MathExp
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.VariableUse
import dk.sdu.mmmi.mdsd.math.MyEntity
import dk.sdu.mmmi.mdsd.math.LocalEntity
import dk.sdu.mmmi.mdsd.math.GlobalEntity
import dk.sdu.mmmi.mdsd.math.Number
import dk.sdu.mmmi.mdsd.math.Expression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute

		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}

	def static compute(MathExp math) {
		variables = new HashMap()
		for (entity : math.entities) {
			variables.put(entity.name, entity.exp.computeExp(new HashMap()))
		}
		return variables
	}

	def dispatch static int computeExp(Expression exp, HashMap<String, Integer> localEntity) {
		switch exp {
			Plus: exp.left.computeExp(localEntity) + exp.right.computeExp(localEntity)
			Minus: exp.left.computeExp(localEntity) - exp.right.computeExp(localEntity)
			Mult: exp.left.computeExp(localEntity) * exp.right.computeExp(localEntity)
			Div: exp.left.computeExp(localEntity) / exp.right.computeExp(localEntity)
			Number: exp.value
			GlobalEntity: exp.exp.computeExp(localEntity) // GlobalEntity.exp...
			default: 0
		}
	}

	def dispatch static int computeExp(LocalEntity entity, HashMap<String, Integer> localEntity) {
		val n = new HashMap(localEntity)
		n.put(entity.name, entity.localExp.computeExp(n))
		entity.exp.computeExp(n)
	}

	def dispatch static int computeExp(VariableUse use, HashMap<String, Integer> localEntity) {
		val entity = variables.get(use.ref.name)
		val lEntity = localEntity.get(use.ref.name)
		switch use.ref {
			LocalEntity: return lEntity !== null ? lEntity : entity
			GlobalEntity: return entity !== null ? entity : use.ref.computeExp(localEntity)
		}
	}

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
			resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
		}

		JOptionPane.showMessageDialog(null, resultString, "Math Language", JOptionPane.INFORMATION_MESSAGE)
	}

}
